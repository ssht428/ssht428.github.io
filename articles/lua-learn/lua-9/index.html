<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Lua元表与元方法</title>
        <link rel="stylesheet" type="text/css" media="all" href="../../../style.css">
    </head>
    <body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">
        <div id="page" class="hfeed">
            <div id="main">
                <div id="primary">
                    <div id="content" role="main">        
                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">
                            <header class="entry-header">
                                <h1 class="entry-title">Lua元表与元方法</h1>
                            </header>
                            <div class="entry-content">
<br><a href="../../../index.html"> Home </a> 
<br>
<br>
<p>
&nbsp;&nbsp;&nbsp; Lua中提供的元表是用于帮助Lua数据变量完成某些非预定义功能的个性化行为，如两个table的相加。假设a和b都是table，通过元表可以定义如何计算表达式a+b。当Lua试图将两个table相加时，它会先检查两者之一是否有元表，然后检查该元表中是否存在__add字段，如果有，就调用该字段对应的值。这个值就是所谓的“元方法”，这个函数用于计算table的和。<br>&nbsp;&nbsp; &nbsp;Lua中每个值都有一个元表。table和userdata可以有各自独立的元表，而其它数据类型的值则共享其类型所属的单一元表。缺省情况下，table在创建时没有元表，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;t = {}</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;print(getmetatable(t))&nbsp; <span style="color: rgba(0, 128, 0, 1)">--输出为nil</span></span><br>&nbsp;&nbsp; &nbsp;这里我们可以使用setmetatable函数来设置或修改任何table的元表。<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;t1 = {}</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;setmetatable(t,t1)</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;assert(getmetatable(t) == t1)</span><br>&nbsp;&nbsp; &nbsp;任何table都可以作为任何值的元表，而一组相关的table也可以共享一个通用的元表，此元表将描述了它们共同的行为。一个table甚至可以作为它自己的元表，用于描述其特有的行为。在Lua代码中，只能设置table的元表，若要设置其它类型值的元表，则必须通过C代码来完成。<br><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp; &nbsp;1. 算术类的元方法：</span><br>&nbsp;&nbsp; &nbsp;在下面的示例代码中，将用table来表示集合，并且有一些函数用来计算集合的并集和交集等。</p>

<pre> Set = {}<br> <span style="color: rgba(0, 0, 255, 1)">local</span> metatable = {} <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">元表</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">根据参数列表中的值创建一个新的集合</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.new(l)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> set = {}<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">将所有由该方法创建的集合的元表都指定到metatable</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(set,metatable)<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> _, v <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">ipairs</span>(l) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         set[v] = <span style="color: rgba(0, 0, 255, 1)">true</span><br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> set<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">取两个集合并集的函数</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.union(a,b)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> res = Set.new{}<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> k <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(a) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         res[k] = <span style="color: rgba(0, 0, 255, 1)">true</span><br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">for</span> k <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(b) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         res[k] = <span style="color: rgba(0, 0, 255, 1)">true</span><br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> res<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">取两个集合交集的函数</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.intersection(a,b)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> res = Set.new{}<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> k <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(a) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         res[k] = b[k]<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> res<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.<span style="color: rgba(255, 0, 255, 1)">tostring</span>(set)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> l = {}<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> e <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(set) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         l[#l + <span style="color: rgba(128, 0, 128, 1)">1</span>] = e<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{</span><span style="color: rgba(128, 0, 0, 1)">"</span> .. <span style="color: rgba(255, 0, 255, 1)">table.concat</span>(l,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">, </span><span style="color: rgba(128, 0, 0, 1)">"</span>) .. <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">}</span><span style="color: rgba(128, 0, 0, 1)">"</span>;<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.<span style="color: rgba(255, 0, 255, 1)">print</span>(s)<br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(Set.<span style="color: rgba(255, 0, 255, 1)">tostring</span>(s))<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">最后将元方法加入到元表中，这样当两个由Set.new方法创建出来的集合进行</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">加运算时，将被重定向到Set.union方法，乘法运算将被重定向到Set.intersection</span><span style="color: rgba(0, 128, 0, 1)"><br></span> metatable.__add = Set.union<br> metatable.__mul = Set.intersection<br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面为测试代码</span><span style="color: rgba(0, 128, 0, 1)"><br></span> s1 = Set.new{<span style="color: rgba(128, 0, 128, 1)">10</span>,<span style="color: rgba(128, 0, 128, 1)">20</span>,<span style="color: rgba(128, 0, 128, 1)">30</span>,<span style="color: rgba(128, 0, 128, 1)">50</span>}<br> s2 = Set.new{<span style="color: rgba(128, 0, 128, 1)">30</span>,<span style="color: rgba(128, 0, 128, 1)">1</span>}<br> s3 = s1 + s2<br> Set.<span style="color: rgba(255, 0, 255, 1)">print</span>(s3)<br> Set.<span style="color: rgba(255, 0, 255, 1)">print</span>(s3 * s1)<br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">{1, 30, 10, 50, 20}</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">{30, 10, 50, 20}</span></pre>

<p>&nbsp;&nbsp;&nbsp; 在元表中，每种算术操作符都有对应的字段名，除了上述的<span style="color: rgba(0, 0, 255, 1)">__add(加法)</span>和<span style="color: rgba(0, 0, 255, 1)">__mul(乘法)</span>外，还有<span style="color: rgba(0, 0, 255, 1)">__sub(减法)</span>、<span style="color: rgba(0, 0, 255, 1)">__div(除法)</span>、<span style="color: rgba(0, 0, 255, 1)">__unm(相反数)</span>、<span style="color: rgba(0, 0, 255, 1)">__mod(取模)</span>和<span style="color: rgba(0, 0, 255, 1)">__pow(乘幂)</span>。此外，还可以定义<span style="color: rgba(0, 0, 255, 1)">__concat</span>字段，用于描述连接操作符的行为。<br>&nbsp;&nbsp; &nbsp;对于上面的示例代码，我们在算术运算符的两侧均使用了table类型的操作数。那么如果为s1 = s1 + 8，Lua是否还能正常工作呢？答案是肯定的，因为Lua定位元表的步骤为，如果第一个值有元表，且存在__add字段，那么Lua将以这个字段为元方法，否则会再去查看第二个值否是有元表且包含__add字段，如果有则以此字段为元方法。最后，如果两个值均不存在元方法，Lua就引发一个错误。然而对于上例中的Set.union函数，如果执行s1 = s1 + 8将会引发一个错误，因为8不是table对象，不能基于它执行pairs方法调用。为了得到更准确的错误信息，我们需要给Set.union函数做如下的修改，如：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.union(a,b)<br>     <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(255, 0, 255, 1)">getmetatable</span>(a) ~= metatable <span style="color: rgba(0, 0, 255, 1)">or</span> <span style="color: rgba(255, 0, 255, 1)">getmetatable</span>(b) ~= metatable <span style="color: rgba(0, 0, 255, 1)">then</span><br>         <span style="color: rgba(255, 0, 255, 1)">error</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">attempt to 'add' a set with a non-set value</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">后面的代码与上例相同。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     ... ...<br> <span style="color: rgba(0, 0, 255, 1)">end</span></pre>

<p><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp; &nbsp;2. 关系类的元方法：</span><br>&nbsp;&nbsp; &nbsp;元表还可以指定关系操作符的含义，元方法分别为__eq(等于)、__lt(小于)和__le(小于等于)，至于另外3个关系操作符，Lua没有提供相关的元方法，可以通过前面3个关系运算符的取反获得。见如下示例：</p>

<pre> Set = {}<br> <span style="color: rgba(0, 0, 255, 1)">local</span> metatable = {}<br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.new(l)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> set = {}<br>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(set,metatable)<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> _, v <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">ipairs</span>(l) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         set[v] = <span style="color: rgba(0, 0, 255, 1)">true</span><br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> set<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> metatable.__le = <span style="color: rgba(0, 0, 255, 1)">function</span>(a,b) <br>     <span style="color: rgba(0, 0, 255, 1)">for</span> k <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(a) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(0, 0, 255, 1)">not</span> b[k] <span style="color: rgba(0, 0, 255, 1)">then</span> <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span> <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> metatable.__lt = <span style="color: rgba(0, 0, 255, 1)">function</span>(a,b) <span style="color: rgba(0, 0, 255, 1)">return</span> a &lt;= b <span style="color: rgba(0, 0, 255, 1)">and</span> <span style="color: rgba(0, 0, 255, 1)">not</span> (b &lt;= a) <span style="color: rgba(0, 0, 255, 1)">end</span><br> metatable.__eq = <span style="color: rgba(0, 0, 255, 1)">function</span>(a,b) <span style="color: rgba(0, 0, 255, 1)">return</span> a &lt;= b <span style="color: rgba(0, 0, 255, 1)">and</span> b &lt;= a <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面是测试代码：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> s1 = Set.new{<span style="color: rgba(128, 0, 128, 1)">2</span>,<span style="color: rgba(128, 0, 128, 1)">4</span>}<br> s2 = Set.new{<span style="color: rgba(128, 0, 128, 1)">4</span>,<span style="color: rgba(128, 0, 128, 1)">10</span>,<span style="color: rgba(128, 0, 128, 1)">2</span>}<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(s1 &lt;= s2) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">true</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(255, 0, 255, 1)">print</span>(s1 &lt; s2)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">true</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(255, 0, 255, 1)">print</span>(s1 &gt;= s1) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">true</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(255, 0, 255, 1)">print</span>(s1 &gt; s1)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">false</span></pre>

<p>&nbsp;&nbsp;&nbsp; 与算术类的元方法不同，关系类的元方法不能应用于混合的类型。<br><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 3. 库定义的元方法：</span><br>&nbsp;&nbsp; &nbsp;除了上述基于操作符的元方法外，Lua还提供了一些针对框架的元方法，如print函数总是调用tostring来格式化其输出。如果当前对象存在<span style="color: rgba(0, 0, 255, 1)">__tostring</span>元方法时，tostring将用该元方法的返回值作为自己的返回值，如：</p>

<pre> Set = {}<br> <span style="color: rgba(0, 0, 255, 1)">local</span> metatable = {}<br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.new(l)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> set = {}<br>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(set,metatable)<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> _, v <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">ipairs</span>(l) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         set[v] = <span style="color: rgba(0, 0, 255, 1)">true</span><br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> set<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Set.<span style="color: rgba(255, 0, 255, 1)">tostring</span>(set)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> l = {}<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> e <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(set) <span style="color: rgba(0, 0, 255, 1)">do</span><br>         l[#l + <span style="color: rgba(128, 0, 128, 1)">1</span>] = e<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{</span><span style="color: rgba(128, 0, 0, 1)">"</span> .. <span style="color: rgba(255, 0, 255, 1)">table.concat</span>(l,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">, </span><span style="color: rgba(128, 0, 0, 1)">"</span>) .. <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">}</span><span style="color: rgba(128, 0, 0, 1)">"</span>;<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br>  <br> metatable.__tostring = Set.<span style="color: rgba(255, 0, 255, 1)">tostring</span><br> <br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面是测试代码：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> s1 = Set.new{<span style="color: rgba(128, 0, 128, 1)">4</span>,<span style="color: rgba(128, 0, 128, 1)">5</span>,<span style="color: rgba(128, 0, 128, 1)">10</span>}<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(s1) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">{5,10,4}</span></pre>

<p>&nbsp;&nbsp;&nbsp; 函数setmetatable和getmetatable也会用到元表中的一个字段(<span style="color: rgba(0, 0, 255, 1)">__metatable</span>)，用于保护元表，如：</p>

<pre> mt.__metatable = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">not your business</span><span style="color: rgba(128, 0, 0, 1)">"</span><br> s1 = Set.new{}<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(255, 0, 255, 1)">getmetatable</span>(s1))   <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">此时将打印"not your business"</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(s1,{})  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">此时将输出错误信息："cannot change protected metatable"</span></pre>

<p>&nbsp;&nbsp;&nbsp; 从上述代码的输出结果即可看出，一旦设置了__metatable字段，getmetatable就会返回这个字段的值，而setmetatable将引发一个错误。<br><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 4. table访问的元方法：</span><br>&nbsp;&nbsp; &nbsp;算术类和关系类运算符的元方法都为各种错误情况定义了行为，它们不会改变语言的常规行为。但是Lua还提供了一种可以改变table行为的方法。有两种可以改变的table行为：查询table及修改table中不存在的字段。<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;1). <span style="color: rgba(0, 0, 255, 1)">__index</span>元方法：<br>&nbsp;&nbsp;&nbsp; 当访问table中不存在的字段时，得到的结果为nil。如果我们为该table定义了元方法__index，那个访问的结果将由该方法决定。见如下示例代码：</p>

<pre> Window = {} <br> Window.prototype = {x = <span style="color: rgba(128, 0, 128, 1)">0</span>, y = <span style="color: rgba(128, 0, 128, 1)">0</span>, width = <span style="color: rgba(128, 0, 128, 1)">100</span>, height = <span style="color: rgba(128, 0, 128, 1)">100</span>}<br> Window.mt = {}  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">Window的元表</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Window.new(o)<br>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(o,Window.mt)<br>     <span style="color: rgba(0, 0, 255, 1)">return</span> o<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">将Window的元方法__index指向一个匿名函数</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">匿名函数的参数table和key取自于table.key。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> Window.mt.__index = <span style="color: rgba(0, 0, 255, 1)">function</span>(table,key) <span style="color: rgba(0, 0, 255, 1)">return</span> Window.prototype[key] <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面是测试代码：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> w = Window.new{x = <span style="color: rgba(128, 0, 128, 1)">10</span>, y = <span style="color: rgba(128, 0, 128, 1)">20</span>}<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(w.width)   <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出100</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(255, 0, 255, 1)">print</span>(w.width1)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">由于Window.prototype变量中也不存在该字段，因此返回nil。</span></pre>

<p>&nbsp;&nbsp;&nbsp; 最后，Lua为__index元方法提供了一种更为简洁的表示方式，如：Window.mt.__index = Window.prototype。该方法等价于上例中的匿名函数表示方法。相比而言，这种简洁的方法执行效率更高，但是函数的方法扩展性更强。<br>&nbsp;&nbsp;&nbsp; 如果想在访问table时禁用__index元方法，可以通过函数<span style="color: rgba(0, 0, 255, 1)">rawget(table,key)</span>完成。通过该方法并不会加速table的访问效率。<br><br>&nbsp;&nbsp;&nbsp; 2). <span style="color: rgba(0, 0, 255, 1)">__newindex</span>元方法：<br>&nbsp;&nbsp; &nbsp;和__index不同的是，该元方法用于不存在键的赋值，而前者则用于访问。当对一个table中不存在的索引赋值时，解释器就会查找__newindex元方法。如果有就调用它，而不是直接赋值。如果这个元方法指向一个table，Lua将对此table赋值，而不是对原有的table赋值。此外，和__index一样，Lua也同样提供了避开元方法而直接操作当前table的函数<span style="color: rgba(0, 0, 255, 1)">rawset(table,key,value)</span>，其功能类似于rawget(table,key)。<br><br>&nbsp;&nbsp;&nbsp; 3). 具有默认值的table：<br>&nbsp;&nbsp; &nbsp;缺省情况下，table的字段默认值为nil。但是我们可以通过元表修改这个默认值，如：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> setDefault(table,default)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> mt = {__index = <span style="color: rgba(0, 0, 255, 1)">function</span>() <span style="color: rgba(0, 0, 255, 1)">return</span> default <span style="color: rgba(0, 0, 255, 1)">end</span> }<br>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(table,mt)<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> tab = {x = <span style="color: rgba(128, 0, 128, 1)">10</span>, y = <span style="color: rgba(128, 0, 128, 1)">20</span>}<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(tab.x,tab.z)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">10    nil</span><span style="color: rgba(0, 128, 0, 1)"><br></span> setDefault(tab,<span style="color: rgba(128, 0, 128, 1)">0</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(tab.x,tab.z)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">10    0</span></pre>

<p><br>&nbsp;&nbsp;&nbsp; 4). 跟踪table的访问：<br>&nbsp;&nbsp; &nbsp;__index和__newindex都是在table中没有所需访问的index时才发挥作用的。因此，为了监控某个table的访问状况，我们可以为其提供一个空table作为代理，之后再将__index和__newindex元方法重定向到原来的table上，见如下代码：</p>

<pre> t = {}        <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">原来的table</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">local</span>  = t  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">保持对原有table的私有访问。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> t = {}        <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">创建代理</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">创建元表</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">local</span> mt = {<br>     __index = <span style="color: rgba(0, 0, 255, 1)">function</span>(table,key)<br>         <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">access to element </span><span style="color: rgba(128, 0, 0, 1)">"</span> .. <span style="color: rgba(255, 0, 255, 1)">tostring</span>(key))<br>         <span style="color: rgba(0, 0, 255, 1)">return</span> [key]  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">通过访问原来的表返回字段值</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">end</span>,<br>     <br>     __newindex = <span style="color: rgba(0, 0, 255, 1)">function</span>(table,key,value)<br>         <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">update of element </span><span style="color: rgba(128, 0, 0, 1)">"</span> .. <span style="color: rgba(255, 0, 255, 1)">tostring</span>(key) .. <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)"> to </span><span style="color: rgba(128, 0, 0, 1)">"</span> .. <span style="color: rgba(255, 0, 255, 1)">tostring</span>(value))<br>         [key] = value  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">更新原来的table</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">end</span><br> }<br> <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(t,mt)<br> <br> t[<span style="color: rgba(128, 0, 128, 1)">2</span>] = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">hello</span><span style="color: rgba(128, 0, 0, 1)">"</span><br> <span style="color: rgba(255, 0, 255, 1)">print</span>(t[<span style="color: rgba(128, 0, 128, 1)">2</span>])<br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">update of element 2 to hello</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">access to element 2</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">hello</span></pre>

<p><br>&nbsp;&nbsp;&nbsp; 5). 只读的table：<br>&nbsp;&nbsp; &nbsp;通过代理的概念，可以很容易的实现只读table。只需跟踪所有对table的更新操作，并引发一个错误即可，见如下示例代码：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> readOnly(t)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> proxy = {}<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> mt = {<br>         __index = t,<br>         __newindex = <span style="color: rgba(0, 0, 255, 1)">function</span>(t,k,v)<br>             <span style="color: rgba(255, 0, 255, 1)">error</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">attempt to update a read-only table</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>         <span style="color: rgba(0, 0, 255, 1)">end</span><br>     }<br>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(proxy,mt)<br>     <span style="color: rgba(0, 0, 255, 1)">return</span> proxy<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> days = readOnly{<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Sunday</span><span style="color: rgba(128, 0, 0, 1)">"</span>,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Monday</span><span style="color: rgba(128, 0, 0, 1)">"</span>,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Tuesday</span><span style="color: rgba(128, 0, 0, 1)">"</span>,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Wednesday</span><span style="color: rgba(128, 0, 0, 1)">"</span>,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Thursday</span><span style="color: rgba(128, 0, 0, 1)">"</span>,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Friday</span><span style="color: rgba(128, 0, 0, 1)">"</span>,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Saturday</span><span style="color: rgba(128, 0, 0, 1)">"</span>}<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(days[<span style="color: rgba(128, 0, 128, 1)">1</span>])<br> days[<span style="color: rgba(128, 0, 128, 1)">2</span>] = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Noday</span><span style="color: rgba(128, 0, 0, 1)">"</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--[[</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">Sunday<br></span> <span style="color: rgba(0, 128, 0, 1)">lua: d:/test.lua:6: attempt to update a read-only table<br></span> <span style="color: rgba(0, 128, 0, 1)">stack traceback:<br></span> <span style="color: rgba(0, 128, 0, 1)">        [C]: in function 'error'<br></span> <span style="color: rgba(0, 128, 0, 1)">        d:/test.lua:6: in function &lt;d:/test.lua:5&gt;<br></span> <span style="color: rgba(0, 128, 0, 1)">        d:/test.lua:15: in main chunk<br></span> <span style="color: rgba(0, 128, 0, 1)">        [C]: ?<br></span> <span style="color: rgba(0, 128, 0, 1)">]]--</span></pre>


</p>

                            </div>
                        </article>
                    </div>
                </div>
            </div>
          <footer id="colophon" role="contentinfo">
	<div id="site-generator">孙悟空 from 吉林大学自动化 @ sunwukong@sangkeji.com</div>
	<script src="../../../footer.js"></script>
          </footer>
        </div>
    </body>
</html>
