<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Lua面向对象</title>
        <link rel="stylesheet" type="text/css" media="all" href="../../../style.css">
    </head>
    <body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">
        <div id="page" class="hfeed">
            <div id="main">
                <div id="primary">
                    <div id="content" role="main">        
                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">
                            <header class="entry-header">
                                <h1 class="entry-title">Lua面向对象</h1>
                            </header>
                            <div class="entry-content">
<br><a href="../../../index.html"> Home </a> 
<br>
<br>
<p>
&nbsp;&nbsp;&nbsp; Lua中的table就是一种对象，但是如果直接使用仍然会存在大量的问题，见如下代码：</p>

<pre> Account = {balance = <span style="color: rgba(128, 0, 128, 1)">0</span>}<br> <span style="color: rgba(0, 0, 255, 1)">function</span> Account.withdraw(v)<br>     Account.balance = Account.balance - v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面是测试调用函数</span><span style="color: rgba(0, 128, 0, 1)"><br></span> Account.withdraw(<span style="color: rgba(128, 0, 128, 1)">100.00</span>)</pre>

<p>&nbsp;&nbsp;&nbsp; 在上面的withdraw函数内部依赖了全局变量Account，一旦该变量发生改变，将会导致withdraw不再能正常的工作，如：</p>

<pre> a = Account; Account = <span style="color: rgba(0, 0, 255, 1)">nil</span><br> a.withdraw(<span style="color: rgba(128, 0, 128, 1)">100.00</span>)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">将会导致访问空nil的错误。</span></pre>

<p>&nbsp;&nbsp;&nbsp; 这种行为明显的违反了面向对象封装性和实例独立性。要解决这一问题，我们需要给withdraw函数在添加一个参数<span style="color: rgba(0, 0, 255, 1)">self</span>，他等价于Java/C++中的this，见如下修改：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> Account.withdraw(self,v)<br>     self.balance = self.balance - v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面是基于修改后代码的调用：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> a1 = Account; Account = <span style="color: rgba(0, 0, 255, 1)">nil</span><br> a1.withdraw(a1,<span style="color: rgba(128, 0, 128, 1)">100.00</span>)  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">正常工作。</span></pre>

<p>&nbsp;&nbsp;&nbsp; 针对上述问题，Lua提供了一种更为便利的语法，即将点<strong><span style="color: rgba(0, 0, 255, 1)">(.)</span></strong>替换为冒号<strong><span style="color: rgba(0, 0, 255, 1)">(:)</span></strong>，这样可以在定义和调用时均隐藏self参数，如:</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> Account:withdraw(v)<br>     self.balance = self.balance - v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">调用代码可改为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> a:withdraw(<span style="color: rgba(128, 0, 128, 1)">100.00</span>)</pre>

<p><br>&nbsp;&nbsp;&nbsp; <span style="color: rgba(128, 0, 128, 1); font-size: 15px">1. 类：</span><br>&nbsp;&nbsp; &nbsp;Lua在语言上并没有提供面向对象的支持，因此想实现该功能，我们只能通过table来模拟，见如下代码及关键性注释：</p>

<pre> <span style="color: rgba(0, 128, 0, 1)">--[[</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">在这段代码中，我们可以将Account视为class的声明，如Java中的：<br></span> <span style="color: rgba(0, 128, 0, 1)">public class Account <br></span> <span style="color: rgba(0, 128, 0, 1)">{<br></span> <span style="color: rgba(0, 128, 0, 1)">    public float balance = 0;<br></span> <span style="color: rgba(0, 128, 0, 1)">    public Account(Account o);<br></span> <span style="color: rgba(0, 128, 0, 1)">    public void deposite(float f);<br></span> <span style="color: rgba(0, 128, 0, 1)">}<br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">]]</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里balance是一个公有的成员变量。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> Account = {balance = <span style="color: rgba(128, 0, 128, 1)">0</span>}<br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">new可以视为构造函数</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> Account:new(o)<br>     o = o <span style="color: rgba(0, 0, 255, 1)">or</span> {} <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">如果参数中没有提供table，则创建一个空的。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">将新对象实例的metatable指向Account表(类)，这样就可以将其视为模板了。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(o,self)<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">在将Account的__index字段指向自己，以便新对象在访问Account的函数和字段时，可被直接重定向。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     self.__index = self<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">最后返回构造后的对象实例</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">return</span> o<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">deposite被视为Account类的公有成员函数</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> Account:deposit(v)<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里的self表示对象实例本身</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     self.balance = self.balance + v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面的代码创建两个Account的对象实例</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">通过Account的new方法构造基于该类的示例对象。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> a = Account:new()<br> <span style="color: rgba(0, 128, 0, 1)">--[[</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">这里需要具体解释一下，此时由于table a中并没有deposite字段，因此需要重定向到Account，<br></span> <span style="color: rgba(0, 128, 0, 1)">同时调用Account的deposite方法。在Account.deposite方法中，由于self(a对象)并没有balance<br></span> <span style="color: rgba(0, 128, 0, 1)">字段，因此在执行self.balance + v时，也需要重定向访问Account中的balance字段，其缺省值为0。<br></span> <span style="color: rgba(0, 128, 0, 1)">在得到计算结果后，再将该结果直接赋值给a.balance。此后a对象就拥有了自己的balance字段和值。<br></span> <span style="color: rgba(0, 128, 0, 1)">下次再调用该方法，balance字段的值将完全来自于a对象，而无需在重定向到Account了。<br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">]]</span><br> a:deposit(<span style="color: rgba(128, 0, 128, 1)">100.00</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(a.balance) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出100</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br> b = Account:new()<br> b:deposit(<span style="color: rgba(128, 0, 128, 1)">200.00</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(b.balance) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出200</span></pre>

<p><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 2. 继承：</span><br>&nbsp;&nbsp; &nbsp;继承也是面向对象中一个非常重要的概念，在Lua中我们仍然可以像模拟类那样来进一步实现面向对象中的继承机制，见如下代码及关键性注释：</p>

<pre> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">需要说明的是，这段代码仅提供和继承相关的注释，和类相关的注释在上面的代码中已经给出。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> Account = {balance = <span style="color: rgba(128, 0, 128, 1)">0</span>}<br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Account:new(o)<br>     o = o <span style="color: rgba(0, 0, 255, 1)">or</span> {}<br>     <span style="color: rgba(255, 0, 255, 1)">setmetatable</span>(o,self)<br>     self.__index = self<br>     <span style="color: rgba(0, 0, 255, 1)">return</span> o<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Account:deposit(v)<br>     self.balance = self.balance + v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> Account:withdraw(v)<br>     <span style="color: rgba(0, 0, 255, 1)">if</span> v &gt; self.balance <span style="color: rgba(0, 0, 255, 1)">then</span><br>         <span style="color: rgba(255, 0, 255, 1)">error</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Insufficient funds</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     self.balance = self.balance - v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面将派生出一个Account的子类，以使客户可以实现透支的功能。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> SpecialAccount = Account:new()  <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">此时SpecialAccount仍然为Account的一个对象实例</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">派生类SpecialAccount扩展出的方法。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面这些SpecialAccount中的方法代码(getLimit/withdraw)，一定要位于SpecialAccount被Account构造之后。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> SpecialAccount:getLimit()<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">此时的self将为对象实例。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">return</span> self.limit <span style="color: rgba(0, 0, 255, 1)">or</span> <span style="color: rgba(128, 0, 128, 1)">0</span><br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">SpecialAccount将为Account的子类，下面的方法withdraw可以视为SpecialAccount</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">重写的Account中的withdraw方法，以实现自定义的功能。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> SpecialAccount:withdraw(v)<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">此时的self将为对象实例。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">if</span> v - self.balance &gt;= self:getLimit() <span style="color: rgba(0, 0, 255, 1)">then</span><br>         <span style="color: rgba(255, 0, 255, 1)">error</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">Insufficient funds</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br>     self.balance = self.balance - v<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">在执行下面的new方法时，table s的元表已经是SpecialAccount了，而不再是Account。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> s = SpecialAccount:new{limit = <span style="color: rgba(128, 0, 128, 1)">1000.00</span>}<br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">在调用下面的deposit方法时，由于table s和SpecialAccount均未提供该方法，因此访问的仍然是</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">Account的deposit方法。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> s:deposit(<span style="color: rgba(128, 0, 128, 1)">100</span>)<br> <br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">此时的withdraw方法将不再是Account中的withdraw方法，而是SpecialAccount中的该方法。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这是因为Lua先在SpecialAccount(即s的元表)中找到了该方法。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> s:withdraw(<span style="color: rgba(128, 0, 128, 1)">200.00</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(s.balance) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出-100</span></pre>

<p><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 3. 私密性：</span><br>&nbsp;&nbsp; &nbsp;私密性对于面向对象语言来说是不可或缺的，否则将直接破坏对象的封装性。Lua作为一种面向过程的脚本语言，更是没有提供这样的功能，然而和模拟支持类与继承一样，我们仍然可以在Lua中通过特殊的编程技巧来实现它，这里我们应用的是Lua中的闭包函数。该实现方式和前面两个示例中基于元表的方式有着很大的区别，见如下代码示例和关键性注释：</p>

<pre> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里我们需要一个闭包函数作为类的创建工厂</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> newAccount(initialBalance)<br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里的self仅仅是一个普通的局部变量，其含义完全不同于前面示例中的self。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里之所以使用self作为局部变量名，也是为了方便今后的移植。比如，以后</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">如果改为上面的实现方式，这里应用了self就可以降低修改的工作量了。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">local</span> self = {balance = initialBalance} <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里我们可以将self视为私有成员变量</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">local</span> withdraw = <span style="color: rgba(0, 0, 255, 1)">function</span>(v) self.balance = self.balance - v <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">local</span> deposit = <span style="color: rgba(0, 0, 255, 1)">function</span>(v) self.balance = self.balance + v <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 0, 255, 1)">local</span> getBalance = <span style="color: rgba(0, 0, 255, 1)">function</span>() <span style="color: rgba(0, 0, 255, 1)">return</span> self.balance <span style="color: rgba(0, 0, 255, 1)">end</span><br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">返回对象中包含的字段仅仅为公有方法。事实上，我们通过该种方式，不仅可以实现</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">成员变量的私有性，也可以实现方法的私有性，如：</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">local privateFunction = function() --do something end</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">只要我们不在输出对象中包含该方法的字段即可。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">return</span> {withdraw = withdraw, deposit = deposit, getBalance = getBalance}<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">和前面两个示例不同的是，在调用对象方法时，不再需要self变量，因此我们可以直接使用点(.)，</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">而不再需要使用冒号(:)操作符了。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> accl = newAccount(<span style="color: rgba(128, 0, 128, 1)">100.00</span>)<br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">在函数newAccount返回之后，该函数内的“非局部变量”表self就不再能被外部访问了，只能通过</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">该函数返回的对象的方法来操作它们。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> accl.withdraw(<span style="color: rgba(128, 0, 128, 1)">40.00</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(acc1.getBalance())</pre>

<p>&nbsp;&nbsp;&nbsp; 事实上，上面的代码只是给出一个简单的示例，在实际应用中，我们可以将更多的私有变量存放于上例的局部self表中。</p>


</p>

                            </div>
                        </article>
                    </div>
                </div>
            </div>
          <footer id="colophon" role="contentinfo">
	<div id="site-generator">孙悟空 from 吉林大学自动化 @ sunwukong@sangkeji.com</div>
	<script src="../../../footer.js"></script>
          </footer>
        </div>
    </body>
</html>
