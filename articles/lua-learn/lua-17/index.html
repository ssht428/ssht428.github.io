<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Lua-C API简介</title>
        <link rel="stylesheet" type="text/css" media="all" href="../../../style.css">
    </head>
    <body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">
        <div id="page" class="hfeed">
            <div id="main">
                <div id="primary">
                    <div id="content" role="main">        
                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">
                            <header class="entry-header">
                                <h1 class="entry-title">Lua-C API简介</h1>
                            </header>
                            <div class="entry-content">
<br><a href="../../../index.html"> Home </a> 
<br>
<br>
<p>
&nbsp;&nbsp;&nbsp; Lua是一种嵌入式脚本语言，即Lua不是可以单独运行的程序，在实际应用中，主要存在两种应用形式。第一种形式是，C/C++作为主程序，调用Lua代码，此时可以将Lua看做“可扩展的语言”，我们将这种应用称为“应用程序代码”。第二种形式是Lua具有控制权，而C/C++代码则作为Lua的“库代码”。在这两种形式中，都是通过Lua提供的C API完成两种语言之间的通信的。<br><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 1. 基础知识：</span><br>&nbsp;&nbsp; &nbsp;C API是一组能使C/C++代码与Lua交互的函数。其中包括读写Lua全局变量、调用Lua函数、运行一段Lua代码，以及注册C函数以供Lua代码调用等。这里先给出一个简单的示例代码：

<pre> #include &lt;stdio.h&gt;<br> #include &lt;<span style="color: rgba(0, 0, 255, 1)">string</span>.h&gt;<br> #include &lt;lua.hpp&gt;<br> #include &lt;lauxlib.h&gt;<br> #include &lt;lualib.h&gt;<br> <br> <span style="color: rgba(0, 0, 255, 1)">int</span> main(<span style="color: rgba(0, 0, 255, 1)">void</span>)<br> {<br>     <span style="color: rgba(0, 0, 255, 1)">const</span> <span style="color: rgba(0, 0, 255, 1)">char</span>* buff = <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">print(\"hello\")</span><span style="color: rgba(128, 0, 0, 1)">"</span>;<br>     <span style="color: rgba(0, 0, 255, 1)">int</span> error;<br>     lua_State* L = luaL_newstate();<br>     luaL_openlibs(L);<br> <br>     error = luaL_loadbuffer(L,buff,strlen(buff),<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">line</span><span style="color: rgba(128, 0, 0, 1)">"</span>) || lua_pcall(L,<span style="color: rgba(128, 0, 128, 1)">0</span>,<span style="color: rgba(128, 0, 128, 1)">0</span>,<span style="color: rgba(128, 0, 128, 1)">0</span>);<br>     <span style="color: rgba(0, 0, 255, 1)">int</span> s = lua_gettop(L);<br>     <span style="color: rgba(0, 0, 255, 1)">if</span> (error) {<br>         fprintf(stderr,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%s</span><span style="color: rgba(128, 0, 0, 1)">"</span>,lua_tostring(L,-<span style="color: rgba(128, 0, 128, 1)">1</span>));<br>         lua_pop(L,<span style="color: rgba(128, 0, 128, 1)">1</span>);<br>     }<br>     lua_close(L);<br>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span>;<br> }</pre>

<p>&nbsp;&nbsp;&nbsp; 下面是针对以上代码给出的具体解释：<br>&nbsp;&nbsp; &nbsp;1). 上面的代码是基于我的C++工程，而非C工程，因此包含的头文件是lua.hpp，如果是C工程，可以直接包含lua.h。<br>&nbsp;&nbsp; &nbsp;2). Lua库中没有定义任何全局变量，而是将所有的状态都保存在动态结构lua_State中，后面所有的C API都需要该指针作为第一个参数。<br>&nbsp;&nbsp; &nbsp;3). luaL_openlibs函数是用于打开Lua中的所有标准库，如io库、string库等。<br>&nbsp;&nbsp; &nbsp;4). luaL_loadbuffer编译了buff中的Lua代码，如果没有错误，则返回0，同时将编译后的程序块压入虚拟栈中。<br>&nbsp;&nbsp; &nbsp;5). lua_pcall函数会将程序块从栈中弹出，并在保护模式下运行该程序块。执行成功返回0，否则将错误信息压入栈中。<br>&nbsp;&nbsp; &nbsp;6). lua_tostring函数中的-1，表示栈顶的索引值，栈底的索引值为1，以此类推。该函数将返回栈顶的错误信息，但是不会将其从栈中弹出。<br>&nbsp;&nbsp; &nbsp;7). lua_pop是一个宏，用于从虚拟栈中弹出指定数量的元素，这里的1表示仅弹出栈顶的元素。<br>&nbsp;&nbsp; &nbsp;8). lua_close用于释放状态指针所引用的资源。<br><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 2. 栈：</span><br>&nbsp;&nbsp; &nbsp;在Lua和C语言之间进行数据交换时，由于两种语言之间有着较大的差异，比如Lua是动态类型，C语言是静态类型，Lua是自动内存管理，而C语言则是手动内存管理。为了解决这些问题，Lua的设计者使用了虚拟栈作为二者之间数据交互的介质。在C/C++程序中，如果要获取Lua的值，只需调用Lua的C API函数，Lua就会将指定的值压入栈中。要将一个值传给Lua时，需要先将该值压入栈，然后调用Lua的C API，Lua就会获取该值并将其从栈中弹出。为了可以将不同类型的值压入栈，以及从栈中取出不同类型的值，Lua为每种类型均设定了一个特定函数。<br>&nbsp;&nbsp; &nbsp;1). 压入元素：<br>&nbsp;&nbsp; &nbsp;Lua针对每种C类型，都有一个C API函数与之对应，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushnil(lua_State* L);&nbsp; <span style="color: rgba(0, 128, 0, 1)">--nil值</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushboolean(lua_State* L, int b); <span style="color: rgba(0, 128, 0, 1)">--布尔值</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushnumber(lua_State* L, lua_Number n); <span style="color: rgba(0, 128, 0, 1)">--浮点数</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushinteger(lua_State* L, lua_Integer n);&nbsp; <span style="color: rgba(0, 128, 0, 1)">--整型</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushlstring(lua_State* L, const char* s, size_t len); <span style="color: rgba(0, 128, 0, 1)">--指定长度的内存数据</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushstring(lua_State* L, const char* s);&nbsp; <span style="color: rgba(0, 128, 0, 1)">--以零结尾的字符串，其长度可由strlen得出。</span></span><br>&nbsp;&nbsp; &nbsp;对于字符串数据，Lua不会持有他们的指针，而是调用在API时生成一个内部副本，因此，即使在这些函数返回后立刻释放或修改这些字符串指针，也不会有任何问题。<br>&nbsp;&nbsp; &nbsp;在向栈中压入数据时，可以通过调用下面的函数判断是否有足够的栈空间可用，一般而言，Lua会预留20个槽位，对于普通应用来说已经足够了，除非是遇到有很多参数的函数。<br><span style="color: rgba(0, 128, 0, 1)"><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_checkstack(lua_State* L, int extra)</span> --期望得到extra数量的空闲槽位，如果不能扩展并获得，返回false。</span> <br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;2). 查询元素：<br>&nbsp;&nbsp; &nbsp;API使用“索引”来引用栈中的元素，第一个压入栈的为1，第二个为2，依此类推。我们也可以使用负数作为索引值，其中-1表示为栈顶元素，-2为栈顶下面的元素，同样依此类推。<br>&nbsp;&nbsp; &nbsp;Lua提供了一组特定的函数用于检查返回元素的类型，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_isboolean (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_iscfunction (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_isfunction (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_isnil (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_islightuserdata (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_isnumber (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_isstring (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_istable (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_isuserdata (lua_State *L, int index);</span><br>&nbsp;&nbsp; &nbsp;以上函数，成功返回1，否则返回0。需要特别指出的是，对于lua_isnumber而言，不会检查值是否为数字类型，而是检查值是否能转换为数字类型。<br>&nbsp;&nbsp; &nbsp;Lua还提供了一个函数lua_type，用于获取元素的类型，函数原型如下：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_type (lua_State *L, int index);</span><br>&nbsp;&nbsp; &nbsp;该函数的返回值为一组常量值，分别是：<span style="color: rgba(0, 0, 255, 1)">LUA_TNIL、LUA_TNUMBER、LUA_TBOOLEAN、LUA_TSTRING、LUA_TTABLE、LUA_TFUNCTION、LUA_TUSERDATA、LUA_TTHREAD和LUA_TLIGHTUSERDATA</span>。这些常量通常用于switch语句中。<br>&nbsp;&nbsp; &nbsp;除了上述函数之外，Lua还提供了一组转换函数，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_toboolean (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;lua_CFunction lua_tocfunction (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;lua_Integer lua_tointeger (lua_State *L, int index);&nbsp;&nbsp; &nbsp;</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;const char *lua_tolstring (lua_State *L, int index, size_t *len);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;lua_Number lua_tonumber (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;const void *lua_topointer (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;const char *lua_tostring (lua_State *L, int index);</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void *lua_touserdata (lua_State *L, int index);</span><br><span style="color: rgba(0, 128, 0, 1)">&nbsp;&nbsp; &nbsp;--string类型返回字符串长度，table类型返回操作符'#'等同的结果，userdata类型返回分配的内存块长度。</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;size_t lua_objlen (lua_State *L, int index);　</span><br>&nbsp;&nbsp; &nbsp;对于上述函数，如果调用失败，lua_toboolean、lua_tonumber、lua_tointeger和lua_objlen均返回0，而其他函数则返回NULL。在很多时候0不是一个很有效的用于判断错误的值，但是ANSI C没有提供其他可以表示错误的值。因此对于这些函数，在有些情况下需要先使用lua_is*系列函数判断是否类型正确，而对于剩下的函数，则可以直接通过判断返回值是否为NULL即可。<br>&nbsp;&nbsp; &nbsp;对于lua_tolstring函数返回的指向内部字符串的指针，在该索引指向的元素被弹出之后，将无法保证仍然有效。该函数返回的字符串末尾均会有一个尾部0。<br>&nbsp;&nbsp; &nbsp;下面将给出一个工具函数，可用于演示上面提到的部分函数，如：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">static</span> <span style="color: rgba(0, 0, 255, 1)">void</span> stackDump(lua_State* L) <br> {<br>     <span style="color: rgba(0, 0, 255, 1)">int</span> top = lua_gettop(L);<br>     <span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = <span style="color: rgba(128, 0, 128, 1)">1</span>; i &lt;= top; ++i) {<br>         <span style="color: rgba(0, 0, 255, 1)">int</span> t = lua_type(L,i);<br>         <span style="color: rgba(0, 0, 255, 1)">switch</span>(t) {<br>         <span style="color: rgba(0, 0, 255, 1)">case</span> LUA_TSTRING:<br>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">'%s'</span><span style="color: rgba(128, 0, 0, 1)">"</span>,lua_tostring(L,i));<br>             <span style="color: rgba(0, 0, 255, 1)">break</span>;<br>         <span style="color: rgba(0, 0, 255, 1)">case</span> LUA_TBOOLEAN:<br>             printf(lua_toboolean(L,i) ? <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">true</span><span style="color: rgba(128, 0, 0, 1)">"</span> : <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">false</span><span style="color: rgba(128, 0, 0, 1)">"</span>);<br>             <span style="color: rgba(0, 0, 255, 1)">break</span>;<br>         <span style="color: rgba(0, 0, 255, 1)">case</span> LUA_TNUMBER:<br>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%g</span><span style="color: rgba(128, 0, 0, 1)">"</span>,lua_tonumber(L,i));<br>             <span style="color: rgba(0, 0, 255, 1)">break</span>;<br>         <span style="color: rgba(0, 0, 255, 1)">default</span>:<br>             printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%s</span><span style="color: rgba(128, 0, 0, 1)">"</span>,lua_typename(L,t));<br>             <span style="color: rgba(0, 0, 255, 1)">break</span>;<br>         }<br>         printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">"</span>);<br>     }<br>     printf(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>);<br> }</pre>

<p>&nbsp;&nbsp;&nbsp; 3). 其它栈操作函数：<br>&nbsp;&nbsp; &nbsp;除了上面给出的数据交换函数之外，Lua的C API还提供了一组用于操作虚拟栈的普通函数，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;int lua_gettop(lua_State* L); <span style="color: rgba(0, 128, 0, 1)">--返回栈中元素的个数。</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_settop(lua_State* L, int index); <span style="color: rgba(0, 128, 0, 1)">--将栈顶设置为指定的索引值。</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_pushvalue(lua_State* L, int index); <span style="color: rgba(0, 128, 0, 1)">--将指定索引的元素副本压入栈。</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_remove(lua_State* L, int index); <span style="color: rgba(0, 128, 0, 1)">--删除指定索引上的元素，其上面的元素自动下移。</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_insert(lua_State* L, int index); <span style="color: rgba(0, 128, 0, 1)">--将栈顶元素插入到该索引值指向的位置。</span></span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;void lua_replace(lua_State* L, int index); <span style="color: rgba(0, 128, 0, 1)">--弹出栈顶元素，并将该值设置到指定索引上。</span></span><br>&nbsp;&nbsp; &nbsp;Lua还提供了一个宏用于弹出指定数量的元素：<span style="color: rgba(0, 0, 255, 1)">#define lua_pop(L,n)&nbsp; lua_settop(L, -(n) - 1)&nbsp;&nbsp; &nbsp;</span><br>&nbsp;&nbsp; &nbsp;见如下示例代码：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">int</span> main()<br> {<br>     lua_State* L = luaL_newstate();<br>     lua_pushboolean(L,<span style="color: rgba(128, 0, 128, 1)">1</span>);<br>     lua_pushnumber(L,<span style="color: rgba(128, 0, 128, 1)">10</span>);<br>     lua_pushnil(L);<br>     lua_pushstring(L,<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">hello</span><span style="color: rgba(128, 0, 0, 1)">"</span>);<br>     stackDump(L); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">true 10 nil 'hello'</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br>     lua_pushvalue(L,-<span style="color: rgba(128, 0, 128, 1)">4</span>);<br>     stackDump(L); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">true 10 nil 'hello' true</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br>     lua_replace(L,<span style="color: rgba(128, 0, 128, 1)">3</span>);<br>     stackDump(L); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">true 10 true 'hello'</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br>     lua_settop(L,<span style="color: rgba(128, 0, 128, 1)">6</span>);<br>     stackDump(L); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">true 10 true 'hello' nil nil</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br>     lua_remove(L,-<span style="color: rgba(128, 0, 128, 1)">3</span>);<br>     stackDump(L); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">true 10 true nil nil</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br>     lua_settop(L,-<span style="color: rgba(128, 0, 128, 1)">5</span>);<br>     stackDump(L); <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)">true</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <br>     lua_close(L);<br>     <span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(128, 0, 128, 1)">0</span>;<br> }</pre>

<p><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 3. C API中的错误处理：</span><br>&nbsp;&nbsp; &nbsp;1). C程序调用Lua代码的错误处理：<br>&nbsp;&nbsp; &nbsp;通常情况下，应用程序代码是以“无保护”模式运行的。因此，当Lua发现“内存不足”这类错误时，只能通过调用“紧急”函数来通知C语言程序，之后在结束应用程序。用户可通过<span style="color: rgba(0, 0, 255, 1)">lua_atpanic</span>来设置自己的“紧急”函数。如果希望应用程序代码在发生Lua错误时不会退出，可通过调用<span style="color: rgba(0, 0, 255, 1)">lua_pcall</span>函数以保护模式运行Lua代码。这样再发生内存错误时，lua_pcall会返回一个错误代码，并将解释器重置为一致的状态。如果要保护与Lua的C代码，可以使用<span style="color: rgba(0, 0, 255, 1)">lua_cpall</span>函数，它将接受一个C函数作为参数，然后调用这个C函数。<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;2). Lua调用C程序：<br>&nbsp;&nbsp; &nbsp;通常而言，当一个被Lua调用的C函数检测到错误时，它就应该调用<span style="color: rgba(0, 0, 255, 1)">lua_error</span>，该函数会清理Lua中所有需要清理的资源，然后跳转回发起执行的那个lua_pcall，并附上一条错误信息。</p>

</p>

                            </div>
                        </article>
                    </div>
                </div>
            </div>
          <footer id="colophon" role="contentinfo">
	<div id="site-generator">孙悟空 from 吉林大学自动化 @ sunwukong@sangkeji.com</div>
	<script src="../../../footer.js"></script>
          </footer>
        </div>
    </body>
</html>
