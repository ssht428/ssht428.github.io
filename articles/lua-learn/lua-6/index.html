<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Lua编译执行与错误</title>
        <link rel="stylesheet" type="text/css" media="all" href="../../../style.css">
    </head>
    <body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">
        <div id="page" class="hfeed">
            <div id="main">
                <div id="primary">
                    <div id="content" role="main">        
                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">
                            <header class="entry-header">
                                <h1 class="entry-title">Lua编译执行与错误</h1>
                            </header>
                            <div class="entry-content">
<br><a href="../../../index.html"> Home </a> 
<br>
<br>
<p>
<span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 1. 编译：</span><br>&nbsp;&nbsp; &nbsp;Lua中提供了<strong><span style="color: rgba(0, 0, 255, 1)">dofile</span></strong>函数，它是一种内置的操作，用于运行Lua代码块。但实际上dofile只是一个辅助函数，<strong><span style="color: rgba(0, 0, 255, 1)">loadfile</span></strong>才是真正的核心函数。相比于dofile，loadfile只是从指定的文件中加载Lua代码块，然后编译这段代码块，如果有编译错误，就返回nil，同时给出错误信息，但是在编译成功后并不真正的执行这段代码块。因此，我们可以将dofile实现为：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> <span style="color: rgba(255, 0, 255, 1)">dofile</span>(filename)<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> f = <span style="color: rgba(255, 0, 255, 1)">assert</span>(<span style="color: rgba(255, 0, 255, 1)">loadfile</span>(filename))<br>     <span style="color: rgba(0, 0, 255, 1)">return</span> f()<br> <span style="color: rgba(0, 0, 255, 1)">end</span></pre>

<p>&nbsp;&nbsp;&nbsp; 这里如果loadfile执行失败，assert函数将直接引发一个错误。通过dofile的代码，我们还可以看出，如果打算多次运行一个文件中的Lua代码块，我们可以只执行loadfile一次，之后多次运行它返回的结果即可，这样就可以节省多次编译所带来的开销。这一点也是loadfile和dofile在性能上的区别。<br>&nbsp;&nbsp; &nbsp;Lua中还提供了另外一种动态执行Lua代码的方式，即<strong><span style="color: rgba(0, 0, 255, 1)">loadstring</span></strong>函数。顾名思义，相比于loadfile，loadstring的代码源来自于其参数中的字符串，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;f = loadstring("i = i + 1")</span><br>&nbsp;&nbsp; &nbsp;此时f就变成了一个函数，每次调用时就执行"i = i + 1"，如：</p>

<pre> i = <span style="color: rgba(128, 0, 128, 1)">0</span><br> f()  <br> <span style="color: rgba(255, 0, 255, 1)">print</span>(i) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">将输出1</span><span style="color: rgba(0, 128, 0, 1)"><br></span> f()<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(i) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">将输出2</span></pre>

<p>&nbsp;&nbsp;&nbsp; loadstring确实是一个功能强大的函数，但是由此而换来的性能开销也是我们不得不考虑的事情。所以对于很多常量字符串如果仍然使用loadstring方式，那就没有太大意义了，如上面的例子f = loadstring("i = i + 1")，因为我们完全可以通过f = function () i = i + 1 end的形式取而代之。而后者的执行效率要远远高于前者。毕竟后者只编译一次，而前者则在每次调用loadstring时均被编译。对于loadstring，我们还需要注意的是，该函数总是在全局环境中编译它的字符串，因此它将无法文件局部变量，而是只能访问全局变量，如：</p>

<pre> i = <span style="color: rgba(128, 0, 128, 1)">32</span><br> <span style="color: rgba(0, 0, 255, 1)">local</span> i = <span style="color: rgba(128, 0, 128, 1)">0</span><br> f = <span style="color: rgba(255, 0, 255, 1)">loadstring</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">i = i + 1; print(i)</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> g = <span style="color: rgba(0, 0, 255, 1)">function</span>() i = i + <span style="color: rgba(128, 0, 128, 1)">1</span>; <span style="color: rgba(255, 0, 255, 1)">print</span>(i) <span style="color: rgba(0, 0, 255, 1)">end</span><br> f()   <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">f函数中的i为全局变量i，因此输出33</span><span style="color: rgba(0, 128, 0, 1)"><br></span> g()   <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">g函数中的i为局部变量i，因此输出1</span></pre>

<p>&nbsp;&nbsp;&nbsp; 对于loadstring返回的函数，如果需要对一个表达式求值，则必须在其之前添加return，这样才能构成一条语句，返回表达式的值，如：</p>

<pre> i = <span style="color: rgba(128, 0, 128, 1)">32</span><br> f = <span style="color: rgba(255, 0, 255, 1)">loadstring</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">i = i + 1; return i * 2</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(f()) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出66</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(255, 0, 255, 1)">print</span>(f()) <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出68。由于loadstring返回的就是正规的函数，因此可以被反复调用。</span></pre>

<p>&nbsp;&nbsp;&nbsp; Lua将所有独立的程序块视为一个匿名函数的函数体，并且该匿名函数还具有可变长实参，因此在调用loadstring时，可以为其传递参数，如：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">local</span> i = <span style="color: rgba(128, 0, 128, 1)">30</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">下面的...表示变长实参，将值赋给局部变量x。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">local</span> f = <span style="color: rgba(255, 0, 255, 1)">assert</span>(<span style="color: rgba(255, 0, 255, 1)">loadstring</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">local x = ...; return (x + 10)    * 2</span><span style="color: rgba(128, 0, 0, 1)">"</span>)) <br> <span style="color: rgba(0, 0, 255, 1)">for</span> i = <span style="color: rgba(128, 0, 128, 1)">1</span>, <span style="color: rgba(128, 0, 128, 1)">20</span> <span style="color: rgba(0, 0, 255, 1)">do</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(255, 0, 255, 1)">string.rep</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">*</span><span style="color: rgba(128, 0, 0, 1)">"</span>,f(i)))<br> <span style="color: rgba(0, 0, 255, 1)">end</span></pre>

<p><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 2. C代码：</span><br>&nbsp;&nbsp; &nbsp;上一小节介绍的是动态加载Lua代码，而事实上，Lua本身也支持动态加载C动态库中的代码，要完成该操作，我们需要借助于Lua内置的系统函数<strong><span style="color: rgba(0, 0, 255, 1)">package.loadlib</span></strong>。该函数有两个字符串参数，分别是动态库的全文件名和该库包含的函数名称，典型的调用代码如下：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;local path = "/usr/local/lib/test.so"</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;local f = package.loadlib(path,"test_func")</span><br>&nbsp;&nbsp; &nbsp;由于loadlib是非常底层的函数，因为在调用时必须提供完整的路径名和函数名称。<br><br>&nbsp;<span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp; 3. 错误：</span><br>&nbsp;&nbsp; &nbsp;Lua作为一种嵌入式脚本语言，在发生错误时，不应该只是简单的退出或崩溃。相反，一旦有错误发生，Lua就应该结束当前程序块并返回到应用程序。<br>&nbsp;&nbsp; &nbsp;在Lua中我们可以通过error()函数获取错误消息，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;print "enter a number:"</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;n = io.read("*number")</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;if not n then error("invalid input") end</span><br>&nbsp;&nbsp; &nbsp;上面代码中的最后一行我们可以通过Lua提供的另外一个内置函数assert类辅助完成，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;print "enter a number:"</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;n = assert(io.read("*number"),"invalid input")</span><br>&nbsp;&nbsp; &nbsp;assert函数将检查其第一个参数是否为true，如果是，则简单的返回该参数，否则就引发一个错误。第二个参数是可选字符串。<br>&nbsp;&nbsp; &nbsp;对于所有的编程语言而言，错误处理都是一个非常重要的环节。在实际的开发中，没有统一的指导原则，只能是在遇到问题后，经过缜密的分析在结合当时的应用场景，最后结合自己的经验再给出错误的具体处理方式。在有些情况下，我们可以直接返回错误码，而在另外一些情况下，则需要直接抛出错误，让开发者能够快速定位导致错误的代码源。<br><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 4. 错误处理与异常：</span><br>&nbsp;&nbsp; &nbsp;Lua提供了错误处理函数pcall，该函数的第一个参数为需要“保护执行”的函数，如果该函数执行失败，pcall将返回false及错误信息，否则返回true和函数调用的返回值。见如下代码：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> foo()<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> a = <span style="color: rgba(128, 0, 128, 1)">10</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(a[<span style="color: rgba(128, 0, 128, 1)">2</span>])<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> r, msg = <span style="color: rgba(255, 0, 255, 1)">pcall</span>(foo)<br> <span style="color: rgba(0, 0, 255, 1)">if</span> r <span style="color: rgba(0, 0, 255, 1)">then</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">This is ok.</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(0, 0, 255, 1)">else</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">This is error.</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(msg)<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">This is error.</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">d:/test.lua:3: attempt to index local 'a' (a number value)</span></pre>

<p>&nbsp;&nbsp;&nbsp; 我们也可以给pcall函数直接传递匿名函数，如：</p>

<pre> r, msg = <span style="color: rgba(255, 0, 255, 1)">pcall</span>(<span style="color: rgba(0, 0, 255, 1)">function</span>() <span style="color: rgba(255, 0, 255, 1)">error</span>({code = <span style="color: rgba(128, 0, 128, 1)">121</span>}) <span style="color: rgba(0, 0, 255, 1)">end</span>)<br> <span style="color: rgba(0, 0, 255, 1)">if</span> r <span style="color: rgba(0, 0, 255, 1)">then</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">This is ok.</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(0, 0, 255, 1)">else</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">This is error.</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(msg.code)<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">This is error.</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">121</span></pre>

<p><br><span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 5. 错误消息与追溯：</span><br>&nbsp;&nbsp; &nbsp;通常在错误发生时，希望得到更多的调试信息，而不是只有发生错误的位置。至少等追溯到发生错误时和函数调用情况，显示一个完整的函数调用栈轨迹。要完成这一功能，我们需要使用Lua提供的另外一个内置函数<strong><span style="color: rgba(0, 0, 255, 1)">xpcall</span></strong>。该函数除了接受一个需要被调用的函数之外，还接受第二个参数，即错误处理函数。当发生错误时，Lua会在调用栈展开前调用错误处理函数。这样，我们就可以在这个函数中使用debug库的<strong><span style="color: rgba(0, 0, 255, 1)">debug.traceback</span></strong>函数，它会根据调用栈来构建一个扩展的错误消息。如：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> errorFunc()<br>     <span style="color: rgba(0, 0, 255, 1)">local</span> a = <span style="color: rgba(128, 0, 128, 1)">20</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(a[<span style="color: rgba(128, 0, 128, 1)">10</span>])<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">function</span> errorHandle()<br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(255, 0, 255, 1)">debug.traceback</span>())<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(255, 0, 255, 1)">xpcall</span>(errorFunc,errorHandle) <span style="color: rgba(0, 0, 255, 1)">then</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">This is OK.</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(0, 0, 255, 1)">else</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">This is error.</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--[[</span><span style="color: rgba(0, 128, 0, 1)">stack traceback:<br></span> <span style="color: rgba(0, 128, 0, 1)">        d:/test.lua:7: in function &lt;d:/test.lua:6&gt;<br></span> <span style="color: rgba(0, 128, 0, 1)">        d:/test.lua:3: in function &lt;d:/test.lua:1&gt;<br></span> <span style="color: rgba(0, 128, 0, 1)">        [C]: in function 'xpcall'<br></span> <span style="color: rgba(0, 128, 0, 1)">        d:/test.lua:10: in main chunk<br></span> <span style="color: rgba(0, 128, 0, 1)">        [C]: ?<br></span> <span style="color: rgba(0, 128, 0, 1)">This is error.<br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">]]</span></pre>


</p>

                            </div>
                        </article>
                    </div>
                </div>
            </div>
          <footer id="colophon" role="contentinfo">
	<div id="site-generator">孙悟空 from 吉林大学自动化 @ sunwukong@sangkeji.com</div>
	<script src="../../../footer.js"></script>
          </footer>
        </div>
    </body>
</html>
