<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Lua数据持久化</title>
        <link rel="stylesheet" type="text/css" media="all" href="../../../style.css">
    </head>
    <body class="post-template-default single single-post postid-14 single-format-standard logged-in admin-bar single-author singular two-column left-sidebar customize-support">
        <div id="page" class="hfeed">
            <div id="main">
                <div id="primary">
                    <div id="content" role="main">        
                        <article id="post-14" class="post-14 post type-post status-publish format-standard hentry category-18">
                            <header class="entry-header">
                                <h1 class="entry-title">Lua数据持久化</h1>
                            </header>
                            <div class="entry-content">
<br><a href="../../../index.html"> Home </a> 
<br>
<br>
<p>
<span style="color: rgba(128, 0, 128, 1); font-size: 15px">&nbsp;&nbsp;&nbsp; 1. 数据文件：</span><br>&nbsp;&nbsp; &nbsp;我们可以利用Lua中table的构造式来定义一种文件格式，即文件中的数据是table构造并初始化的代码，这种方式对于Lua程序而言是非常方便和清晰的，如：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;Entry { "Stephen Liu", "Male", "Programmer", "BS" }</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;Entry { "Jerry Tian", "Male", "Programmer", "BS" }</span><br>&nbsp;&nbsp; &nbsp;需要注意的是，Entry{&lt;code&gt;}等价于Entry({&lt;code&gt;})，对于上面的数据条目，如果我们能够定义一个合适的Entry函数，就可以让这些数据成为我们Lua代码的一部分了。见如下代码及其注释：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">local</span> count = <span style="color: rgba(128, 0, 128, 1)">0</span><br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里预先定义了Entry函数，以便在执行dofile中的数据代码时，可以找到匹配的该函数。</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 0, 255, 1)">function</span> Entry() count = count + <span style="color: rgba(128, 0, 128, 1)">1</span> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(255, 0, 255, 1)">dofile</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">d:/lua_data.conf</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(255, 0, 255, 1)">print</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">number of entries: </span><span style="color: rgba(128, 0, 0, 1)">"</span> .. count)<br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">number of entries: 2</span></pre>

<p>&nbsp;&nbsp;&nbsp; 相比于上面数据文件的格式，我们还可以定义一种更为清晰的“自描述的数据”格式，其中每项数据都伴随一个表示其含义的简短描述。采用这样的格式，即便今后数据项发生了变化，我们仍然可以在改动极小的情况下保持向后的兼容性。见如下数据格式和相关的代码：<br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;Entry { name = "Stephen Liu", gender = "Male", job = "Programmer", education = "BS" }</span><br><span style="color: rgba(0, 0, 255, 1)">&nbsp;&nbsp; &nbsp;Entry { name = "Jerry Tian", gender = "Male", job = "Programmer", education = "BS" }</span></p>

<pre> <span style="color: rgba(0, 0, 255, 1)">local</span> personInfo = {}<br> <span style="color: rgba(0, 0, 255, 1)">function</span> Entry(b) <br>     <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这里将table对象b的name字段值作为personInfo的key信息。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>     <span style="color: rgba(0, 0, 255, 1)">if</span> b.name <span style="color: rgba(0, 0, 255, 1)">then</span><br>         personInfo[b.name] = <span style="color: rgba(0, 0, 255, 1)">true</span> <br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(255, 0, 255, 1)">dofile</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">d:/lua_data.conf</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br> <span style="color: rgba(0, 0, 255, 1)">for</span> name <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(personInfo) <span style="color: rgba(0, 0, 255, 1)">do</span><br>     <span style="color: rgba(255, 0, 255, 1)">print</span>(name)<br> <span style="color: rgba(0, 0, 255, 1)">end</span><br> <br> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">输出结果为：</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">Jerry Tian</span><span style="color: rgba(0, 128, 0, 1)"><br></span> <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">Stephen Liu</span></pre>

<p>&nbsp;&nbsp;&nbsp; 可以看出这些代码片段都采用了事件驱动的做法。Entry函数作为一个回调函数，在执行dofile时为数据文件中的每个条目所调用。<br>&nbsp;&nbsp; &nbsp;Lua不仅运行速度快，而且编译速度也快。这主要是因为Lua在设计之初就将数据描述作为Lua的主要应用之一所致。<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<span style="color: rgba(128, 0, 128, 1); font-size: 15px">2. 序列化：</span><br>&nbsp;&nbsp;&nbsp; 相信有Java或C#开发经验的人对于这一术语并不陌生。就是将数据对象转换为字节流后在通过IO输出到文件或网络，读取的时候再将这些数据重新构造为与原始对象具有相同值的新对象。或者我们也可以将一段可执行的Lua代码作为序列化后的数据格式。比如：varname = &lt;expr&gt;，这里的&lt;expr&gt;表示计算变量varname的表达式。下面的示例代码用于序列化无环的table：</p>

<pre> <span style="color: rgba(0, 0, 255, 1)">function</span> serialize(o)<br>     <span style="color: rgba(0, 0, 255, 1)">if</span> <span style="color: rgba(255, 0, 255, 1)">type</span>(o) == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">number</span><span style="color: rgba(128, 0, 0, 1)">"</span> <span style="color: rgba(0, 0, 255, 1)">then</span><br>         <span style="color: rgba(255, 0, 255, 1)">io.write</span>(o)<br>     <span style="color: rgba(0, 0, 255, 1)">elseif</span> <span style="color: rgba(255, 0, 255, 1)">type</span>(o) == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">string</span><span style="color: rgba(128, 0, 0, 1)">"</span> <span style="color: rgba(0, 0, 255, 1)">then</span><br>         <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">string.format函数的"%q"参数可以转义字符串中的元字符。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>         <span style="color: rgba(255, 0, 255, 1)">io.write</span>(<span style="color: rgba(255, 0, 255, 1)">string.format</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">%q</span><span style="color: rgba(128, 0, 0, 1)">"</span>,o)) <br>     <span style="color: rgba(0, 0, 255, 1)">elseif</span> <span style="color: rgba(255, 0, 255, 1)">type</span>(o) == <span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">table</span><span style="color: rgba(128, 0, 0, 1)">"</span> <span style="color: rgba(0, 0, 255, 1)">then</span><br>         <span style="color: rgba(255, 0, 255, 1)">io.write</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">{\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>         <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">迭代table中的各个元素，同时递归的写出各个字段的value。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>         <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">由此可以看出，这个简单例子可以支持嵌套的table。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>         <span style="color: rgba(0, 0, 255, 1)">for</span> k,v <span style="color: rgba(0, 0, 255, 1)">in</span> <span style="color: rgba(255, 0, 255, 1)">pairs</span>(o) <span style="color: rgba(0, 0, 255, 1)">do</span><br>             <span style="color: rgba(0, 128, 0, 1)">--</span><span style="color: rgba(0, 128, 0, 1)">这样做是为了防止k中包含非法的Lua标识符。</span><span style="color: rgba(0, 128, 0, 1)"><br></span>             <span style="color: rgba(255, 0, 255, 1)">io.write</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)"> [</span><span style="color: rgba(128, 0, 0, 1)">"</span>); serialize(k); <span style="color: rgba(255, 0, 255, 1)">io.write</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">] = </span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>             serialize(v)<br>             <span style="color: rgba(255, 0, 255, 1)">io.write</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">,\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>         <span style="color: rgba(0, 0, 255, 1)">end</span><br>         <span style="color: rgba(255, 0, 255, 1)">io.write</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">}\n</span><span style="color: rgba(128, 0, 0, 1)">"</span>)<br>     <span style="color: rgba(0, 0, 255, 1)">else</span><br>         <span style="color: rgba(255, 0, 255, 1)">error</span>(<span style="color: rgba(128, 0, 0, 1)">"</span><span style="color: rgba(128, 0, 0, 1)">cannot serialize a </span><span style="color: rgba(128, 0, 0, 1)">"</span> .. <span style="color: rgba(255, 0, 255, 1)">type</span>(o))<br>     <span style="color: rgba(0, 0, 255, 1)">end</span><br> <span style="color: rgba(0, 0, 255, 1)">end</span></pre>

</p>

                            </div>
                        </article>
                    </div>
                </div>
            </div>
          <footer id="colophon" role="contentinfo">
	<div id="site-generator">孙悟空 from 吉林大学自动化 @ sunwukong@sangkeji.com</div>
	<script src="../../../footer.js"></script>
          </footer>
        </div>
    </body>
</html>
